package com.classicmodels.repository;

import static com.classicmodels.converter.YearMonthConverter.YEARMONTH;
import com.classicmodels.pojos.ImmutableCustomer;
import com.classicmodels.pojos.ImmutableDepartment;
import com.classicmodels.pojos.SimpleCustomer;
import com.classicmodels.pojos.SimpleDepartment;
import com.classicmodels.pojos.SimpleEmployee;
import java.util.List;
import static jooq.generated.tables.Customer.CUSTOMER;
import static jooq.generated.tables.Department.DEPARTMENT;
import static jooq.generated.tables.Employee.EMPLOYEE;
import org.jooq.DSLContext;
import static org.jooq.impl.DSL.concat;
import static org.jooq.impl.DSL.val;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

@Repository
@Transactional(readOnly = true)
public class ClassicModelsRepository {

    private final DSLContext ctx;

    public ClassicModelsRepository(DSLContext ctx) {
        this.ctx = ctx;
    }

    // jOOQ generated POJOs like those from Example 1.3 via <pojos>true</pojos> 
    public void fetchSimplePojoExamples() {

        List<SimpleCustomer> result1 = ctx.select(
                CUSTOMER.CUSTOMER_NAME, CUSTOMER.FIRST_BUY_DATE.coerce(YEARMONTH).as("ym"))
                .from(CUSTOMER)
                .fetchInto(SimpleCustomer.class);        
        System.out.println("Example 1.1\n" + result1);
        
        // CUSTOMER.FIRST_BUY_DATE is ignored (it needs the proper alias), so POJOs's "ym"  field is set to null
        // CUSTOMER.PHONE is ignored
        List<SimpleCustomer> result2 = ctx.select(
                CUSTOMER.CUSTOMER_NAME, CUSTOMER.PHONE, CUSTOMER.FIRST_BUY_DATE.coerce(YEARMONTH))
                .from(CUSTOMER)
                .fetchInto(SimpleCustomer.class);        
        System.out.println("Example 1.2\n" + result2);
        
        List<SimpleDepartment> result3 = ctx.select(
                DEPARTMENT.NAME, DEPARTMENT.CODE, DEPARTMENT.TOPIC)
                .from(DEPARTMENT)
                .fetchInto(SimpleDepartment.class);
        System.out.println("Example 1.3\n" + result3);
        
        List<SimpleEmployee> result4 = ctx.select(EMPLOYEE.FIRST_NAME.as("fn"), EMPLOYEE.LAST_NAME.as("ln"),  
                concat(EMPLOYEE.employee().FIRST_NAME, val(" "), EMPLOYEE.employee().LAST_NAME).as("boss"))
                .from(EMPLOYEE)
                .fetchInto(SimpleEmployee.class);
        System.out.println("Example 1.4\n" + result4);                        
    }
    
    // This kind of POJOs are generated by jOOQ via <immutablePojos>true</immutablePojos> 
    public void fetchImmutablePojoExamples() {

        // require an exact match between the fetched fields and POJO's fields
        List<ImmutableCustomer> result1 = ctx.select(
                CUSTOMER.CUSTOMER_NAME, CUSTOMER.FIRST_BUY_DATE.coerce(YEARMONTH).as("ym"))
                .from(CUSTOMER)
                .fetchInto(ImmutableCustomer.class);        
        System.out.println("Example 2.1\n" + result1);
        
        // DEPARTMENT.PHONE, DEPARTMENT.OFFICE_CODE - are ignored
        // since DEPARTMENT.CODE is not fetched the POJO's "code" field is set to null
        List<ImmutableDepartment> result2 = ctx.select(
                DEPARTMENT.NAME, DEPARTMENT.PHONE, DEPARTMENT.OFFICE_CODE, DEPARTMENT.TOPIC)
                .from(DEPARTMENT)
                .fetchInto(ImmutableDepartment.class);
        System.out.println("Example 2.2\n" + result2);
    }
    
    public void fetchProxyablePojoExamples() {                
        // fluent setters!
    }
}
